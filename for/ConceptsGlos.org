* Concepts in Programing Languages

General Reading Place = 36, 37,38

** Námsfókus

*** Hugtök sem dæmakennari mælti með
**** activation record
http://en.wikipedia.org/wiki/Activation_record#Structure

A call stack is composed of stack frames (also called activation records or activation 
frames). These are machine dependent and ABI-dependent data structures containing 
subroutine state information. Each stack frame corresponds to a call to a subroutine 
which has not yet terminated with a return. For example, if a subroutine named DrawLine 
is currently running, having been called by a subroutine DrawSquare, the top part of 
the call stack might be laid out like this:


top of the stack
| Locals of Drawline        |  <-- Stack Pointer
|---------------------------|
| Return Address            |
|---------------------------|  <-- Frame Pointer
| Parameters for Drawline   |
|---------------------------|
|---------------------------|  \
| Locals of DrawSquare      |   
|---------------------------|
| Return Address            |     stack frame for DrawSquare subroutine
|---------------------------|
| Parameters for DrawSquare |
|---------------------------|  /
|---------------------------|
| ....                      |


***** Call stack
http://en.wikipedia.org/wiki/Call_stack

"the stack" means implicitly "the callstack of the thread or task in question"
interesting sidetrack->
                         fourth
http://en.wikipedia.org/wiki/Forth_programming_language



**** access link
or static link,
from:
http://en.wikipedia.org/wiki/Access_link#Structure
This is called an access link or static link (as it keeps track of static nesting
during dynamic and recursive calls) and provides the routine (as well as any other 
routines it may invoke) access to the local data of its encapsulating routines at 
every nesting level. Some architectures, compilers, or optimization cases store one 
link for each enclosing level (not just the immediately enclosing), so that deeply 
nested routines that access shallow data do not have to traverse several links; this 
strategy is often called a display

**** block structured programing languages
http://www.csse.monash.edu.au/~lloyd/tildeProgLang/PL-Block/

http://en.wikipedia.org/wiki/Block_%28programming%29

The function of blocks in programming is to enable groups of statements to be 
treated as if they were one statement, and to narrow the lexical scope of variables, 
procedures and functions declared in a block so that they do not conflict with 
variables having the same name used elsewhere in a program for different purposes.

The notion of blocks is introduced by different syntax in different languages, but 
there are two broad families: the ALGOL family in which blocks are delimited by the 
keywords begin and end, and the C family in which blocks are delimited by curly 
braces { and }. Some other techniques used are indentation, and s-expressions* with a 
syntactic keyword such as lambda or let (as in the Lisp family).


In a block-structured programing language, the names og variables and other objects 
such as procedures which are declared in outer blocks are visible inside other inner
blocks, unless they are shadowed by an object of the same name.



***** s-expressions
http://en.wikipedia.org/wiki/S-expression


**** closures

In computer science, a closure (also lexical closure or function closure) is a function 
or reference to a function together with a referencing environment—a table storing a 
reference to each of the non-local variables (also called free variables) of that 
function.[1] A closure—unlike a plain function pointer—allows a function to access 
those non-local variables even when invoked outside of its immediate lexical scope.

in haskell:
http://stackoverflow.com/questions/9088295/closures-in-haskell
This is because Haskell essentially creates functions with free variables everywhere, 
and thus, closures are created all the time. Some of these might be optimized away by the 
compiler, but it is safe to assume that there will be more closures used than you might 
ever be able to discover on your own.
So, don't try to locate closures; they are nothing special in Haskell and are used all the time.

in scheme:

(define (add a)
  (lambda (b)
    (+ a b)))
(define add3 (add 3))

>(add3 4)
7


// What you can see is that when you call add with the parameter a (which is 3), that value is 
// contained in the closure of the returned function that we're defining to be add3. That way, 
when we call add3 it knows where to find a value to perform the addition.

**** streams
pott þétt eitt dæmi á prófi stútað ef þetta er á hreinu

** Computer Architecture
bls. 35

Von Neuman Architecture
